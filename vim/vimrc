" modeline {
" vim:set ft=vim sw=2 ts=2 sts=2 et tw=78 foldmarker={,} spell:
" }

" variables {

" g:sys {
let s:tmp_ignorecase = &ignorecase

" temp set ignorecase
let &ignorecase = 1

let g:sys = {}
let g:sys.uname =  system('uname -s')
let g:sys.osx =    (g:sys.uname =~ 'darwin') || has('macunix')
let g:sys.linux =  (g:sys.uname =~ 'linux') && has('unix') && !g:sys.osx
let g:sys.win =    has('win16') || has('win32') || has('win64')
let g:sys.unix =   has('unix') && !g:sys.osx && !g:sys.win
let g:sys.gui =    has('gui_running')
let g:sys.macvim = has('gui_macvim')
let g:sys.lua =    has('lua')
let g:sys.nvim =   has('nvim')
let g:sys.python = has('python')
let g:sys.ruby =   has('ruby')
let g:sys.has256 = (&term =~ '256color') || g:sys.gui

" reset changes and clean up
let &ignorecase = s:tmp_ignorecase
unlet s:tmp_ignorecase
" }

" g:opts {
let g:opts = {
      \ 'colors': {
      \   'dark': {
      \     'airline': 'hybrid',
      \     'background': 'dark',
      \     'scheme': 'hybrid'
      \   },
      \   'light': {
      \     'airline': 'papercolor',
      \     'background': 'light',
      \     'scheme': 'papercolor'
      \   },
      \   'use_dark': 1
      \ },
      \ 'encoding': 'utf-8',
      \ 'font_dir': expand('~/.fonts'),
      \ 'leader': '\<space>',
      \ 'patched_font': 'Inconsolata for Powerline Nerd Font Complete.otf',
      \ 'patched_font_rel_dir': 'Inconsolata/complete',
      \ 'vim_home': expand('~/.vim')
      \ }

if g:sys.win
  let g:opts.patched_font = 'Inconsolata for Powerline Nerd Font Complete Windows Compatible.otf'
  " use vim_home instead of default vimfiles
  set runtimepath=g:opts.vim_home,$VIM/vimfiles,$VIMRUNTIME,$VIM/vimfiles/after,g:opts.vim_hom/after
elseif g:sys.nvim
  let g:opts.vim_home = expand('~/.config/nvim')
endif

let g:opts.backup_dir = expand(g:opts.vim_home . '/.backup')
let g:opts.plugin_dir = expand(g:opts.vim_home . '/bundle')
let g:opts.undo_dir = expand(g:opts.backup_dir . '/undo')

if g:sys.osx
  let g:opts.font_dir = expand('~/Library/Fonts')
endif

if g:opts.colors.use_dark
  let s:colors = g:opts.colors.dark
else
  let s:colors = g:opts.colors.light
endif
" default to base16 when term is 16 color or less
if &t_Co <= 16
  let s:colors.scheme = 'base16-default'
endif

" }

" }

" important {
if &compatible
  set nocompatible
endif

let &encoding = g:opts.encoding
scriptencoding g:opts.encoding

set pastetoggle=<F12> " pastetoggle (sane indentation on paste)

" if g:opts.leader is a space, map <space> to <leader>
if g:opts.leader ==? '\<space>' || g:opts.leader ==? ' '
  map <space> <leader>
  map <space><space> <leader><leader>
else
  " change mapleader <leader> to g:opts.leader,
  " but retain default for local buffers
  " setting here causes this to be set for any <leader> references later
  " in the initialization sequence

  let mapleader = g:opts.leader
  let maplocalleader = "\\"
endif
" }

" functions {

" CopyFile {
function! CopyFile(src, dest)
  let ret = writefile(readfile(a:src, 'b'), a:dest, 'b')
  if ret == -1
    return 0
  endif
  return 1
endfunction
" }

" InstallFont {
function! InstallFont(src, dest)
  let src_font_path = expand(a:src)
  let src_font = fnamemodify(src_font_path, ':t')
  let dest_dir = expand(a:dest)
  let dest_font = expand(a:dest . '/' . src_font)

  if filereadable(src_font_path)
    call MakeDir(dest_dir)

    if !filereadable(dest_font)
      echom "Copying font from: '" . src_font_path . "' to: '" . dest_font . "'"
      call CopyFile(src_font_path, dest_font)

      if g:sys.win
        echom "Attempting to install font: " .  dest_font
        let font_name = fnamemodify(dest_font, ':t')

        call PowerShellCmd([
              \ "(New-Object -ComObject Shell.Application).Namespace(0x14).CopyHere('" . dest_font . "', 0x10)"
              \ ])

        if filereadable(expand($windir . '/fonts/' . font_name))
          echom "Successfully installed font: " . font_name
        else
          echoerr "Unable to install, please manually install the font: " . dest_font
        endif
      endif

      if executable('fc-cache')
        echom 'Updating font cache'
        system('fc-cache -f ' . g:sysvars.fonts)
      endif
    endif
  endif
endfunction
" }

" InstallFonts {
function! InstallFonts(src, dest)
  let src_dir = expand(a:src)
  let dest_dir = expand(a:dest)

  if isdirectory(src_dir)
    call MakeDir(dest_dir)

    let src_fonts = split(globpath(src_dir, '**/*.[ot]tf'), '\n')
    for src_font in src_fonts
      call InstallFont(src_font, dest_dir)
    endfor
  endif
endfunction
"}

" MakeDir {
function! MakeDir(path)
  if !isdirectory(expand(a:path))
    silent call mkdir(expand(a:path), 'p')
  endif
endfunction
" }

" PowerShellCmd {
function! PowerShellCmd(cmds)
  let tmp = {
        \ 'shell': &shell,
        \ 'shellcmdflag': &shellcmdflag,
        \ 'shellpipe': &shellpipe,
        \ 'shellredir': &shellredir
        \ }

  let &shell = 'powershell.exe -ExecutionPolicy Unrestricted'
  let &shellcmdflag = '-Command'
  let &shellpipe = '>'
  let &shellredir = '>'

  for cmd in a:cmds
    silent execute '!' . cmd
  endfor

  let &shell = tmp.shell
  let &shellcmdflag = tmp.shellcmdflag
  let &shellpipe = tmp.shellpipe
  let &shellredir = tmp.shellredir
  unlet tmp
endfunction
" }

" }

" pathogen {

" setup pathogen
runtime bundle/vim-pathogen/autoload/pathogen.vim

" disable unsupported plugins
if !exists('g:pathogen_disabled')
  let g:pathogen_disabled = []
endif

if !g:sys.lua
  call add(g:pathogen_disabled, 'neocomplete')
endif

if !executable('ctags')
  call add(g:pathogen_disabled, 'tagbar')
endif

if !executable('ack') && !executable('ackgrep') && ! executable('ag')
  call add(g:pathogen_disabled, 'ack')
endif
" code search
if executable('ackgrep')
  let g:ackprg="ack-grep -H --nocolor --nogroup --column"
elseif executable('ag')
  let g:ackprg = 'ag --nogroup --nocolor --column --smart-case'
endif

if !isdirectory('/Applications/Dash.app')
  call add(g:pathogen_disabled, 'dash')
else
  nmap <silent> <leader>ds <Plug>DashSearch
endif

call pathogen#infect()
"call pathogen#helptags()

" }

" vim-plug {

" async processes
" Plug 'Shougo/vimproc.vim', { 'do': 'make' }

" NERDTree
" Plug 'scrooloose/nerdtree'
"       \| Plug 'Xuyuanp/nerdtree-git-plugin'
"       \| Plug 'jistr/vim-nerdtree-tabs',
"       \{ 'on': ['NERDTree', 'NERDTreeToggle', 'NERDTreeTabsToggle'] }

" unite and MRU features
" if g:sys.lua && exists("g:plugs['vimproc.vim']")
"   Plug 'Shougo/unite.vim'
"       \| Plug 'Shougo/vimfiler.vim'
"       \| Plug 'Shougo/neomru.vim'
"       \| Plug 'Shougo/unite-outline'
"       \| Plug 'tsukkee/unite-tag'
" endif

" vim-devicons and pre-patched fonts
" should be loaded after NEDTree, airline and unite
" Plug 'ryanoasis/nerd-fonts' | Plug 'ryanoasis/vim-devicons'

" }

" displaying text {
set number
" }

" syntax, highlighting and spelling {
set synmaxcol=2048 " no need to syntax color super long lines
set hlsearch " highlights matched search pattern
set cursorline " highlight screen line of cursor
set textwidth=80 " highlight 80 column

if exists('&colorcolumn')
  " highlight column at #
  set colorcolumn=80
  let &colorcolumn="80,".join(range(120,999),",")
else
  au BufWinEnter * let w:m2=matchadd('ErrorMsg', '\%>80v.\+', -1)
endif
" }

" printing {
set printoptions=header:0,duplex:long,paper:letter
" }

" messages and info {
set shortmess+=filmnrxoOtT      " abbr. of messages (avoids "hit enter")
set showcmd                     " show partial cmd keys in status bar
" ruler on steroids?
set rulerformat=%30(%=\:b%n%y%m%r%w\ %l,%c%V\ %P%)
set visualbell                  " use visual bell instead of beep
" }

" tabs and indenting {
set tabstop=2 " # spaces <Tab> equals
set shiftwidth=2 " # spaces used for each (auto)indent
set softtabstop=2 " # spaces to insert for tab (<ctrl-v><TAB>)
set shiftround " round to 'shiftwidth' for "<<" and ">>"
set expandtab " expand <TAB> to spaces in Insert mode
set smartindent " do clever autoindenting
" }

" selecting text {
if has('unnamedplus')
  set clipboard=unnamed,unnamedplus " use + register for copy/paste
else
  set clipboard=unnamed " use system clipboard
endif
" }

" editing text {
set completeopt=menu,preview,longest
set showmatch " when inserting bracket, brief jump to match
set nojoinspaces " do not add second space when joining lines
" }

" folding {
if has('folding')
  set foldenable " auto fold code
  set foldmethod=marker " folding type
endif
" }

" reading and writing files {
set nobackup " do not keep a backup ~ file
" list of dirs for backup file
let &backupdir = g:opts.backup_dir . ',.'
set autoread " auto read file modified outside of vim
" create the backup dir if it doesn't exist
if empty(glob(g:opts.backup_dir))
  silent call mkdir(g:opts.backup_dir, 'p')
endif
" }

" the swap file {
set noswapfile " do not use a swap file
" list of dirs for swap files
let &directory = g:opts.backup_dir . ',~/tmp,.'
" }

" command line editing {
" persistent undo
if has('persistent_undo')
  set undofile
  let &undodir = g:opts.undo_dir . ',~/tmp,.'
  " create the backup dir if it doesn't exist
  if empty(glob(g:opts.undo_dir))
    silent call mkdir(g:opts.undo_dir, 'p')
  endif
endif
" }

" executing external commands {
if g:sys.win
  " change to powershell
  "set shell=powershell.exe\ -ExecutionPolicy\ Unrestricted
  "set shellcmdflag=-Command
  "set shellpipe=>
  "set shellredir=>
elseif exists($SHELL)
  set shell=$SHELL " shell to use for ext cmds
endif
" }

" autocmd {
if has('autocmd')
  " recalculate the trailing whitespace warning when idle, and after saving
  au cursorhold,bufwritepost * unlet! b:statusline_trailing_space_warning

  " recalculate the tab warning flag when idle and after writing
  au cursorhold,bufwritepost * unlet! b:statusline_tab_warning

  "recalculate the long line warning when idle and after saving
  au cursorhold,bufwritepost * unlet! b:statusline_long_line_warning

  " automatically switch to the current file directory when a new
  " buffer is opened
  au BufEnter * if bufname("") !~ "^\[A-Za-z0-9\]*://" | lcd %:p:h | endif

  " remember last position in file
  au BufReadPost *
        \ if line("'\"") > 0 && line("'\"") <= line("$") |
        \   exe "normal g`\"" |
        \ endif

  " instead of reverting the cursor to the last position in the buffer,
  " set it to the first line when editing a git commit message
  au FileType gitcommit
        \ au! BufEnter COMMIT_EDITMSG call setpos('.', [0, 1, 1, 0])

  " remove trailing whitespace and ^M chars
  au FileType c,cpp,java,go,php,javascript,python,twig,xml,yml
        \ au BufWritePre <buffer> call StripTrailingWhitespace()

  " format go docs on load
  au FileType go autocmd BufWritePre <buffer> Fmt

  " auto resize window splits
  au VimResized * exe "normal! \<C-w>="

  " set coffeescript filetype, just in case
  au BufNewFile,BufRead *.coffee set filetype=coffee
endif
" }

" GUI (here instead of .gvimrc) {
if g:sys.gui
  set lines=40

  set guioptions-=m " remove the menu
  set guioptions-=T " remove the toolbar
  set guioptions-=t " remove tear-off menus
  set guioptions+=a " visual mode is global
  set guioptions+=c " use :ex prompt instead of modal dialogs

  if g:sys.osx
    " make Mac 'Option' key behave as 'Alt'
    set mmta

    set linespace=2 " # pixel lines between characters
    set guifont=Inconsolata:h14,Monaco:h14,Consolas:h14,Courier\ New:h14,Courier:h14

    " MacVIM shift+arrow-keys behavior (required in .vimrc)
    let macvim_hig_shift_movement = 1
  else
    set guifont=Inconsolata:h14,Monaco:h14,Consolas:h14,Courier\ New:h14,Courier:h14
  endif

  if exists('transparency')
    set transparency=5 " transparency of text bg as %
  endif

  " open macvim in fullscreen
  if g:sys.macvim
    set fuoptions=maxvert,maxhorz
    "au GUIEnter * set fullscreen
  endif

  " setting these in GVim/MacVim because terminals cannot distinguish between
  " <space> and <S-space> because curses sees them the same
  nnoremap <space> <PageDown>
  nnoremap <S-space> <PageUp>

  if has('autocmd')
    " auto resize splits when window resizes
    "autocmd VimResized * wincdm =
  endif
elseif g:sys.has256
  set t_Co=256 " enable 256 colors for CSApprox warning
endif
" }

" keybindings {
" exit insert mode with jj
inoremap jj <ESC>

" make Y consistent with C and D
nnoremap Y y$

" easier window moving
map <C-j> <C-w>j<C-w>_
map <C-k> <C-w>k<C-w>_
map <C-l> <C-w>l<C-w>_
map <C-h> <C-w>h<C-w>_
" }

" plugin config {

" Ctags {
set tags=./tags;/,~/.vimtags

" Make tags placed in .git/tags file available in all levels of a repository
let gitroot = substitute(system('git rev-parse --show-toplevel'), '[\n\r]', '', 'g')
if gitroot != ''
  let &tags = &tags . ',' . gitroot . '/.git/tags'
endif
" }

" ctrlp {
if isdirectory(expand(g:opts.plugin_dir . '/ctrlp.vim'))
  let g:ctrlp_working_path_mode = 'ra'
  nnoremap <silent> <D-t> :CtrlP<CR>
  nnoremap <silent> <D-r> :CtrlPMRU<CR>
  let g:ctrlp_custom_ignore = {
        \ 'dir':  '\.git$\|\.hg$\|\.svn|node_modules|bower_components$',
        \ 'file': '\.exe$\|\.so$\|\.dll$\|\.pyc$' }

  if executable('ag')
    let s:ctrlp_fallback = 'ag %s --nocolor -l -g ""'
  elseif executable('ack-grep')
    let s:ctrlp_fallback = 'ack-grep %s --nocolor -f'
  elseif executable('ack')
    let s:ctrlp_fallback = 'ack %s --nocolor -f'
  " on Windows use "dir" as fallback command.
  elseif g:sys.win
    let s:ctrlp_fallback = 'dir %s /-n /b /s /a-d'
  else
    let s:ctrlp_fallback = 'find %s -type f'
  endif
  if exists("g:ctrlp_user_command")
    unlet g:ctrlp_user_command
  endif
  let g:ctrlp_user_command = {
        \ 'types': {
        \ 1: ['.git', 'cd %s && git ls-files . --cached --exclude-standard --others'],
        \ 2: ['.hg', 'hg --cwd %s locate -I .'],
        \ },
        \ 'fallback': s:ctrlp_fallback
        \ }

  if isdirectory(expand(g:opts.plugin_dir . '/ctrlp-funky'))
    " ctrlp extensions
    let g:ctrlp_extensions = ['funky']

    " funky
    nnoremap <leader>fu :CtrlPFunky<cr>
    " narrow the list down with a word under cursor
    nnoremap <leader>fU :execute 'CtrlPFunky ' . expand('<cword>')<cr>
    let g:ctrlp_funky_matchtype = 'path'
    let g:ctrlp_funky_syntax_highlight = 1
  endif
endif
" }

" emmet-vim {
if isdirectory(expand(g:opts.plugin_dir . '/emmet-vim'))
  let g:user_emmet_mode = 'i' " only enable in insert mode
  let g:user_emmet_leader_key = '<C-y>' " default, change, if necessary
  " only enable for html,css,scss
  let g:user_emmet_install_global = 0
  autocmd FileType html,css,scss EmmetInstall
endif
" }

" fugitive {
if isdirectory(expand(g:opts.plugin_dir . '/vim-fugitive'))
  nnoremap <silent> <leader>gs :Gstatus<CR>
  nnoremap <silent> <leader>gd :Gdiff<CR>
  nnoremap <silent> <leader>gc :Gcommit<CR>
  nnoremap <silent> <leader>gb :Gblame<CR>
  nnoremap <silent> <leader>gl :Glog<CR>
  nnoremap <silent> <leader>gp :Git push<CR>
  nnoremap <silent> <leader>gr :Gread<CR>
  nnoremap <silent> <leader>gw :Gwrite<CR>
  nnoremap <silent> <leader>ge :Gedit<CR>
  " Mnemonic _i_nteractive
  nnoremap <silent> <leader>gi :Git add -p %<CR>
  nnoremap <silent> <leader>gg :SignifyToggle<CR>
endif
" }

" javascript-libraries-syntax.vim {
if isdirectory(expand(g:opts.plugin_dir . '/javascript-libraries-syntax.vim'))
  " jquery,underscore,backbone,prelude,angularjs,angualrui,angularuirouter,react,flux,requirejs,sugar,jasmine,chai,handlebars
  let g:used_javascript_libs = 'jquery,underscore,angularjs,angularui,angularuirouter,react,flux,jamine,chai'
endif
" }

" nerd-fonts {
if isdirectory(expand(g:opts.plugin_dir . '/nerd-fonts'))
  let nerdfont_dir = expand(g:opts.plugin_dir . '/nerd-fonts/patched-fonts')
  let patched_font_dir = expand(nerdfont_dir . '/' . g:opts.patched_font_rel_dir)
  let patched_font = expand(patched_font_dir . '/' . g:opts.patched_font)
  let font_name = substitute(fnamemodify(patched_font, ':t:r'), ' ', '_', 'g')

  call InstallFont(patched_font, g:opts.font_dir)

  if g:sys.gui
    if g:sys.linux
      let &guifont = font_name . '\ 14'
    else
      let &guifont = font_name . ':h14'
    endif
  endif
endif
" }

" netrw {
let g:netrw_silent = 1
let g:netrw_ftpmode = 'ascii'
let g:netrw_ftp_cmd = 'ftp -p'
let g:netrw_longlist = 1
let g:netrw_winsize = 40
let g:netrw_altv = 1
let g:DrChipTopLvlMenu = 'Plugins.'
if g:sys.unix && exists("$DISPLAY")
  let g:netrw_browsex_viewer = 'xdg-open'
endif
" }

" omnicomplete {
if has('autocmd') && exists('+omnifunc')
  autocmd Filetype *
        \if &omnifunc == "" |
        \setlocal omnifunc=syntaxcomplete#Complete |
        \endif
endif

hi Pmenu guifg=#000000 guibg=#F8F8F8 ctermfg=black ctermbg=Lightgray
hi PmenuSbar guifg=#8A95A7 guibg=#F8F8F8 gui=NONE ctermfg=darkcyan ctermbg=lightgray cterm=NONE
hi PmenuThumb guifg=#F8F8F8 guibg=#8A95A7 gui=NONE ctermfg=lightgray ctermbg=darkcyan cterm=NONE

" Some convenient mappings
"inoremap <expr> <Esc>      pumvisible() ? "\<C-e>" : "\<Esc>"
inoremap <expr> <Down>     pumvisible() ? "\<C-n>" : "\<Down>"
inoremap <expr> <Up>       pumvisible() ? "\<C-p>" : "\<Up>"
inoremap <expr> <C-d>      pumvisible() ? "\<PageDown>\<C-p>\<C-n>" : "\<C-d>"
inoremap <expr> <C-u>      pumvisible() ? "\<PageUp>\<C-p>\<C-n>" : "\<C-u>"

" Automatically open and close the popup menu / preview window
au CursorMovedI,InsertLeave * if pumvisible() == 0|silent! pclose|endif
set completeopt=menu,preview,longest
" }

" rainbow {
if exists("g:plugs['rainbow']")
  let g:rainbow_active = 1 " 0 if you want to enable it later via :RainbowToggle
  let g:rainbow_conf = {
        \   'guifgs': ['royalblue3', 'darkorange3', 'seagreen3', 'firebrick'],
        \   'ctermfgs': ['lightblue', 'lightyellow', 'lightcyan', 'lightmagenta'],
        \   'operators': '_,_',
        \   'parentheses': ['start=/(/ end=/)/ fold', 'start=/\[/ end=/\]/ fold', 'start=/{/ end=/}/ fold'],
        \   'separately': {
        \       '*': {},
        \       'tex': {
        \           'parentheses': ['start=/(/ end=/)/', 'start=/\[/ end=/\]/'],
        \       },
        \       'lisp': {
        \           'guifgs': ['royalblue3', 'darkorange3', 'seagreen3', 'firebrick', 'darkorchid3'],
        \       },
        \       'vim': {
        \           'parentheses': ['start=/(/ end=/)/', 'start=/\[/ end=/\]/', 'start=/{/ end=/}/ fold', 'start=/(/ end=/)/ containedin=vimFuncBody', 'start=/\[/ end=/\]/ containedin=vimFuncBody', 'start=/{/ end=/}/ fold containedin=vimFuncBody'],
        \       },
        \       'html': {
        \           'parentheses': ['start=/\v\<((area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)[ >])@!\z([-_:a-zA-Z0-9]+)(\s+[-_:a-zA-Z0-9]+(\=("[^"]*"|'."'".'[^'."'".']*'."'".'|[^ '."'".'"><=`]*))?)*\>/ end=#</\z1># fold'],
        \       },
        \       'css': 0,
        \   }
        \}
endif
" }

" syntastic {
if isdirectory(expand(g:opts.plugin_dir . '/syntastic'))
  set statusline+=%#warningmsg#
  set statusline+=%{SyntasticStatuslineFlag()}
  set statusline+=%*

  let g:syntastic_always_populate_loc_list = 1
  let g:syntastic_auto_loc_list = 1
  let g:syntastic_check_on_open = 1
  let g:syntastic_check_on_wq = 0
endif
" }

" unite {
if isdirectory(expand(g:opts.plugin_dir . '/unite.vim'))
  call unite#filters#matcher_default#use(['matcher_fuzzy'])
  call unite#filters#sorter_default#use(['sorter_rank'])
  "call unite#custom#source('file_rec/async','sorters','sorter_rank', )
  " ctrl+p
  let g:unite_data_directory='~/.vim/.cache/unite'
  let g:unite_enable_start_insert = 1
  let g:unite_source_history_yank_enable = 1
  let g:unite_prompt = '» '
  let g:unite_split_rule = 'botright'
  if executable('ag')
    let g:unite_source_grep_command = 'ag'
    let g:unite_source_grep_default_opts = '--nocolor --nogroup -S -C4'
    let g:unite_source_grep_recursive_opt = ''
  endif
  nnoremap <silent> <c-p> :Unite -auto-resize file file_mru file_rec<cr>

  " ack.vim/ag.vim
  nnoremap <Space>/ :Unite grep:.<CR>

  " yankring/yankstack
  nnoremap <Space>y :Unite history/yank<cr>

  " LustyJuggler
  nnoremap <Space>s :Unite -quick-match buffer<CR>
endif
" }

" vim-airline {
if isdirectory(expand(g:opts.plugin_dir . '/vim-airline'))
  if isdirectory(expand(g:opts.plugin_dir . '/nerd-fonts'))
    let g:airline_powerline_fonts = 1
  else
    if !exists('g:airline_symbols')
      let g:airline_symbols = {}
    endif

    " unicode symbols
    let g:airline_left_sep = '»'
    let g:airline_left_sep = '▶'
    let g:airline_right_sep = '«'
    let g:airline_right_sep = '◀'
    let g:airline_symbols.linenr = '␊'
    let g:airline_symbols.linenr = '␤'
    let g:airline_symbols.linenr = '¶'
    let g:airline_symbols.branch = '⎇'
    let g:airline_symbols.paste = 'ρ'
    let g:airline_symbols.paste = 'Þ'
    let g:airline_symbols.paste = '∥'
    let g:airline_symbols.whitespace = 'Ξ'
    " let g:airline_left_sep = "\ue0b0"
    " let g:airline_left_alt_sep = "\ue0b1"
    " let g:airline_right_sep = "\ue0b2"
    " let g:airline_right_alt_sep = "\ue0b3"
    " let g:airline_symbols.branch = "\ue0a0"
    " let g:airline_symbols.readonly = "\ue0a2"
    " let g:airline_symbols.linenr = "\ue0a1"
  endif
endif
" }

" vim-css-color {
if isdirectory(expand(g:opts.plugin_dir . '/vim-css-color'))
  let g:cssColorVimDoNotMessMyUpdatetime = 1
endif
" }

" vim-css3-syntax {
if isdirectory(expand(g:opts.plugin_dir . '/vim-css3-syntax'))
  highlight VendorPrefix guifg=#00ffff gui=bold
  match VendorPrefix /-\(moz\|webkit\|o\|ms\)-[a-zA-Z-]\+/
endif
" }

" vim-gitgutter {
if isdirectory(expand(g:opts.plugin_dir . '/vim-gitgutter'))
  let g:gitgutter_max_signs = 500  " default value
endif
" }

" vim-jsdoc {
if isdirectory(expand(g:opts.plugin_dir . '/vim-jsdoc'))
  " turn on detecting underscore starting functions as private convention
  let g:jsdoc_underscore_private = 1
  let g:jsdoc_enable_es6 = 1 " allow ES6 shorthand syntax

  " since v0.3 there is no longer a default mapping
  nmap <silent> <leader>jd <Plug>(jsdoc)
endif
" }

" vim-json {
if isdirectory(expand(g:opts.plugin_dir . '/vim-json'))
  let g:vim_json_syntax_conceal = 0
endif
" }

" vim-jsx {
if isdirectory(expand(g:opts.plugin_dir . '/vim-jsx'))
  let g:jsx_ext_required = 0 " allows for jsx syntax in .js files
endif
" }

" vim-less {
if isdirectory(expand(g:opts.plugin_dir . '/vim-less'))
  if executable('lessc')
    nnoremap <Leader>m :w <BAR> !lessc % > %:t:r.css<CR><space>
  endif
endif
" }

" vim-multiple-cursors {
if isdirectory(expand(g:opts.plugin_dir . '/vim-multiple-cursors'))
  let g:multi_cursor_start_key = '<C-d>'
  let g:multi_cursor_start_word_key = 'g<C-d>'
  let g:multi_cursor_next_key = '<C-d>'
  let g:multi_cursor_prev_key = '<C-S-d>'
  let g:multi_cursor_skip_key = '<C-x>'
  let g:multi_cursor_quit_key = '<Esc>'

  let g:multi_cursor_exit_from_visual_mode = 1
  let g:multi_cursor_exit_from_insert_mode = 1

  " account for neocomplete to improve perf
  function! Multiple_cursors_before()
    if exists(':NeoCompleteLock') == 2
      execute 'NeoCompleteLock'
    endif
  endfunction

  function! Multiple_cursors_after()
    if exists(':NeoCompleteUnlock') == 2
      execute 'NeoCompleteUnlock'
    endif
  endfunction

  highlight multiple_cursors_cursor term=reverse cterm=reverse gui=reverse
  highlight link multiple_cursors_visual Visual
endif
" }

" }

" colors {
if exists('&colorcolumn')
  if g:sys.has256
    highlight ColorColumn guibg=#444444 ctermbg=238
  else
    highlight ColorColumn ctermbg=7 ctermfg=1
  endif
endif

if g:sys.has256
  highlight SpellErrors guibg=#8700af ctermbg=91
else
  highlight SpellErrors ctermbg=5 ctermfg=0
endif

if isdirectory(expand(g:opts.plugin_dir . '/seoul256.vim'))
  let g:seoul256_light_background = 256
  let g:seoul256_background = 233
endif

if isdirectory(expand(g:opts.plugin_dir . '/vim-colors-solarized'))
  let g:solarized_termcolors = 256
  let g:solarized_termtrans = 1
  let g:solarized_contrast = "high"
  let g:solarized_visibility = "high"
endif

if isdirectory(expand(g:opts.plugin_dir . '/vim-hybrid'))
  let g:hybrid_custom_term_colors = 1
  let g:hybrid_reduced_contrast = 1 " low contrast colors
endif

if !empty($ITERM_PROFILE)
  " csapprox can look silly on iterm, do not load it
  let g:CSApprox_loaded = 1
endif

if !empty($CONEMUBUILD)
  set term=pcansi
  set t_Co=256
  let &t_AB="\e[48;5;%dm"
  let &t_AF="\e[38;5;%dm"
endif

let &background = s:colors.background
silent! execute 'colorscheme ' . s:colors.scheme
let g:airline_theme = s:colors.airline
" }

